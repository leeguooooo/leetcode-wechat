#!/usr/bin/env -S node --no-warnings --loader ts-node/esm
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { test } from 'tstest';
import { SidecarBody, } from './sidecar-body.js';
import { init, attach, detach, } from './operations.js';
import { Sidecar } from '../decorators/mod.js';
import { INIT_SYMBOL, ATTACH_SYMBOL, DETACH_SYMBOL, } from './constants.js';
const targetProgram = () => process.platform === 'linux' ? '/bin/ls'
    : process.platform === 'darwin' ? '/bin/ls'
        : process.platform === 'win32' ? 'c:\\Windows\\notepad.exe'
            : 'targteProgram(): Unknown process.platform:' + process.platform;
test('init()', async (t) => {
    let SidecarTest = class SidecarTest extends SidecarBody {
    };
    SidecarTest = __decorate([
        Sidecar([targetProgram()])
    ], SidecarTest);
    const s = new SidecarTest();
    const future = new Promise(resolve => s.on(INIT_SYMBOL, resolve));
    try {
        await init(s);
        await Promise.race([
            future,
            new Promise((resolve, reject) => {
                void resolve;
                setTimeout(reject, 100);
            }),
        ]);
        t.pass('init() successfully');
    }
    catch (e) {
        t.fail('Rejection:' + e && e.message);
        console.error(e);
    }
});
test('attach()', async (t) => {
    let SidecarTest = class SidecarTest extends SidecarBody {
    };
    SidecarTest = __decorate([
        Sidecar([targetProgram()])
    ], SidecarTest);
    const sidecar = new SidecarTest();
    sidecar.script = {
        unload: (..._) => { return {}; },
    };
    sidecar.session = {
        detach: (..._) => { return {}; },
    };
    const future = new Promise(resolve => sidecar.on(ATTACH_SYMBOL, resolve));
    try {
        await attach(sidecar);
        await Promise.race([
            future,
            new Promise((resolve, reject) => {
                void resolve;
                setTimeout(reject, 100);
            }),
        ]);
        t.pass('attach() successfully');
    }
    catch (e) {
        t.fail('Rejection:' + e && e.message);
    }
    finally {
        try {
            await detach(sidecar);
        }
        catch (e) { }
    }
});
test('detach()', async (t) => {
    let SidecarTest = class SidecarTest extends SidecarBody {
    };
    SidecarTest = __decorate([
        Sidecar([targetProgram()])
    ], SidecarTest);
    const sidecar = new SidecarTest();
    sidecar.on('error', () => { });
    const future = new Promise(resolve => sidecar.on(DETACH_SYMBOL, resolve));
    try {
        await init(sidecar);
        await attach(sidecar);
        await detach(sidecar);
        await Promise.race([
            future,
            new Promise((resolve, reject) => {
                void resolve;
                setTimeout(reject, 100);
            }),
        ]);
        t.pass('detach() successfully');
    }
    catch (e) {
        t.fail('Rejection:' + e && e.message);
    }
});
//# sourceMappingURL=operations.spec.js.map