var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
/**
 * Huan(202106) see:
 *  http://blog.wolksoftware.com/decorators-metadata-reflection-in-typescript-from-novice-to-expert-part-4
 *
 * TypeScript Decorators Examples
 *  https://gist.github.com/remojansen/16c661a7afd68e22ac6e
 *
 * TypeScript Decorators: Parameter Decorators
 *  https://blog.wotw.pro/typescript-decorators-parameter-decorators/
 */
import 'reflect-metadata';
function decorateProperty(target, key) {
    console.log('decorateProperty');
    const t = Reflect.getMetadata('design:type', target, key);
    console.log(`${key} type: ${t.name}`);
    console.log('t:', t);
}
function decorateMethod(target, key, _descriptor) {
    console.log('decorateMethod');
    const types = Reflect.getMetadata('design:paramtypes', target, key);
    const s = types.map((a) => a.name).join();
    console.log(`${key} param types: ${s}`);
    // const s2 = types.map((a: any) => a).join()
    // console.log(`${key} param types2: ${s2}`)
    const r = Reflect.getMetadata('design:returntype', target, key);
    console.log(`${key} return type: ${r.name}`);
}
function decorateParam(target, propertyKey, parameterIndex) {
    console.log('decorateParam');
    void target;
    void propertyKey;
    void parameterIndex;
}
function decorateClass(constructor) {
    void constructor;
    console.log('decorateClass');
}
let Demo = class Demo {
    constructor() {
        this.attr1 = {};
    }
    doSomething(param1, param2, 
    // param3 : Foo,
    param4, 
    // param5 : InterfaceFoo,
    param6, param7) {
        void param1;
        void param2;
        // void param3
        void param4;
        // void param5
        void param6;
        void param7;
        return 1;
    }
};
__decorate([
    decorateProperty // apply property decorator
    ,
    __metadata("design:type", Demo)
], Demo.prototype, "attr1", void 0);
__decorate([
    decorateMethod // apply parameter decorator
    ,
    __param(0, decorateParam),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Number, Object, Function, Function]),
    __metadata("design:returntype", Number)
], Demo.prototype, "doSomething", null);
Demo = __decorate([
    decorateClass,
    __metadata("design:paramtypes", [])
], Demo);
void Demo;
void decoratorFactory;
function decoratorFactory(...args) {
    switch (args.length) {
        case 1:
            return decorateClass.call(this, args[0]);
        case 2:
            return decorateProperty.call(this, args[0], args[1]);
        case 3:
            if (typeof args[2] === 'number') {
                return decorateParam.call(this, args[0], args[1], args[2]);
            }
            return decorateMethod.call(this, args[0], args[1], args[2]);
        default:
            throw new Error();
    }
}
//# sourceMappingURL=reflect-metadata.js.map