"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateRpcDescriptor = void 0;
const config_js_1 = require("../../config.js");
const ret_js_1 = require("../../ret.js");
const constants_js_1 = require("./constants.js");
function updateRpcDescriptor(target, propertyKey, descriptor) {
    config_js_1.log.verbose('Sidecar', 'updateRpcDescriptor(%s, %s, descriptor)', target.constructor.name, propertyKey);
    // console.log('value:', descriptor.value)
    const ret = descriptor.value();
    if (!(ret instanceof Promise)) {
        const e = new Error(`The "${target.constructor.name}.${propertyKey}" method return a non-promise: it must return the Ret() to make Sidecar @Call happy.`);
        console.error(e.stack);
        throw e;
    }
    else {
        ret.then((result) => {
            /**
             * FIXME: Huan(202006)
             *  check Ret value and deal the error more gentle
             */
            if (result !== ret_js_1.RET_SYMBOL) {
                const e = new Error(`The "${target.constructor.name}.${propertyKey}" method must return the Ret() to make Sidecar @Call happy.`);
                console.error(e.stack);
                throw e;
            }
            return result;
        }).catch((e) => {
            target[constants_js_1.DEBUG_CALL_RET_ERROR] = e;
            console.error(e);
        });
    }
    async function proxyMethod(...args) {
        // // https://github.com/huan/clone-class/blob/master/src/instance-to-class.ts
        // const klass = (this.constructor.name as any as typeof SidecarBody)
        // console.log('target:', target)
        // console.log('target.name:', target.name)
        // console.log('target.constructor.name:', target.constructor.name)
        config_js_1.log.verbose(`${target.constructor.name}<Sidecar>`, `${propertyKey}(%s)`, args.join(', '));
        if (!this.script) {
            config_js_1.log.warn(`Sidecar<${target.constructor.name}>`, '%s(%s) updateRpcDescriptor() > proxyMethod() > "this.script" is undefined.', propertyKey, args.join(', '));
            this.emit('error', new Error('proxyMethod() found this.script is undefined'));
            return;
        }
        return this.script.exports[propertyKey](...args);
    }
    /**
     * Update the method
     */
    descriptor.value = proxyMethod;
    return descriptor;
}
exports.updateRpcDescriptor = updateRpcDescriptor;
//# sourceMappingURL=update-rpc-descriptor.js.map