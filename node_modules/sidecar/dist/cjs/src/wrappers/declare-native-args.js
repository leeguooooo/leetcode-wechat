"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.declareNativeArgs = void 0;
const name_helpers_js_1 = require("./name-helpers.js");
function declareNativeArgs() {
    const name = this.name;
    const paramTypeList = this.paramTypeList;
    /**
     * There's no any parameters needed
     */
    if (!Array.isArray(paramTypeList) || paramTypeList.length === 0) {
        return '';
    }
    const declareStatementList = [];
    for (const [argIdx, paramTypeChain] of paramTypeList.entries()) {
        /**
         * 0. Loop for all parameter args...
         */
        const [nativeType, ...pointerTypeList] = paramTypeChain;
        // console.log(argIdx, nativeType, pointerTypeList)
        const statementChain = [];
        /**
         * 1. arg is non-pointer
         */
        if (nativeType !== 'pointer') {
            statementChain.push(`// non-pointer type for arg[${argIdx}]: ${nativeType}`, `const ${(0, name_helpers_js_1.nativeArgName)(name, argIdx)} = ${(0, name_helpers_js_1.argName)(argIdx)}`);
            declareStatementList.push(statementChain.join('\n'));
            continue;
        }
        if (pointerTypeList.length === 0) {
            /**
             * 2. arg is a pointer
             */
            statementChain.push(`// pointer type for arg[${argIdx}] -> ${pointerTypeList.join(' -> ')}`, 
            // Number() is to convert the `null` to number
            `const ${(0, name_helpers_js_1.nativeArgName)(name, argIdx)} = ptr(Number(${(0, name_helpers_js_1.argName)(argIdx)}))`);
        }
        else { // pointerTypeList.length > 0
            /**
             * 3. arg is a pointer to pointer...
             */
            statementChain.push(...generatePointerTypeStatementChain(name, argIdx, pointerTypeList));
        }
        declareStatementList.push(statementChain.join('\n'));
    }
    return declareStatementList.join('\n\n');
}
exports.declareNativeArgs = declareNativeArgs;
function generatePointerTypeStatementChain(name, argIdx, pointerTypeList) {
    const statementChain = [];
    /**
     * Current arg is a native pointer
     */
    statementChain.push(`// pointer type for arg[${argIdx}] -> ${pointerTypeList.join(' -> ')}`, 
    // FIXME: Huan(202106) how to get the size? (1024)
    `const ${(0, name_helpers_js_1.nativeArgName)(name, argIdx)} = Memory.alloc(1024 /*Process.pointerSize*/)`);
    let lastVarName = (0, name_helpers_js_1.nativeArgName)(name, argIdx);
    for (const [typeIdx, pointerType] of pointerTypeList.entries()) {
        if (pointerType === 'Pointer') {
            statementChain.push(`const ${(0, name_helpers_js_1.bufName)(name, argIdx, typeIdx)} = Memory.alloc(Process.pointerSize)`, `${lastVarName}.writePointer(${(0, name_helpers_js_1.bufName)(name, argIdx, typeIdx)})`);
            lastVarName = (0, name_helpers_js_1.bufName)(name, argIdx, typeIdx);
        }
        else {
            /**
             * Best Practices: String allocation (UTF-8/UTF-16/ANSI)
             *  https://frida.re/docs/best-practices/
             *
             * Huan(202106) FIXME: alloc memory for string before assign to native argumenments
             */
            statementChain.push(`${lastVarName}.write${pointerType}(${(0, name_helpers_js_1.argName)(argIdx)})`);
        }
    }
    return statementChain;
}
//# sourceMappingURL=declare-native-args.js.map