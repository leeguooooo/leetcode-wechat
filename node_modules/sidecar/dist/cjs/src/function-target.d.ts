/**
 * Huan(202106):
 *  - type: agent
 *    A label for the frida target address
 *    This is for the dynamic purpose,
 *    i.e. we need to call/hook a PTR that generated by the init agent.
 *  - type: objc:
 *    ??
 *  - type: module
 *    loadModule('libc', 'open')
 *
 * See: Jumping to Labels in Inline Assembly
 *  https://docs.microsoft.com/en-us/cpp/assembler/inline/jumping-to-labels-in-inline-assembly
 *
 */
/**
* Function Target
*
*  number: memory address of the function
*    - 0x1234
*
*  string: export name of the function
*    - lib: 'open'
*    - ObjC: '- connection:didReceiveData:'
*/
/**
 * Memory address
 */
export interface TargetPayloadAddress {
    address: string;
    moduleName: null | string;
    type: 'address';
}
/**
 * The variable name in the `initAgentScript`
 */
export interface TargetPayloadAgent {
    type: 'agent';
    funcName: string;
}
/**
 * The module name and the module export
 */
export interface TargetPayloadExport {
    exportName: string;
    moduleName: null | string;
    type: 'export';
}
export declare type TargetPayloadRaw = number | string;
export declare type TargetPayloadObj = TargetPayloadAddress | TargetPayloadAgent | TargetPayloadExport;
export declare type FunctionTarget = TargetPayloadRaw | TargetPayloadObj;
export declare type FunctionTargetType = TargetPayloadObj['type'];
declare const addressTarget: (address: number, moduleName?: null | string) => TargetPayloadAddress;
declare const agentTarget: (funcName: string) => TargetPayloadAgent;
declare const exportTarget: (exportName: string, moduleName?: null | string) => TargetPayloadExport;
/**
 * Convert the `string` and `number` type target to Obj
 */
declare function normalizeFunctionTarget(target: FunctionTarget): TargetPayloadObj;
export { addressTarget, agentTarget, exportTarget, normalizeFunctionTarget, };
//# sourceMappingURL=function-target.d.ts.map