"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SidecarBody = void 0;
/**
 * Sidecar Bodywork
 *
 * Huan <zixia@zixia.net>, June 24, 2021
 *  https://github.com/huan/sidecar
 */
const build_agent_source_js_1 = require("../agent/build-agent-source.js");
const metadata_sidecar_js_1 = require("../decorators/sidecar/metadata-sidecar.js");
const config_js_1 = require("../config.js");
const frida = __importStar(require("../frida.js"));
const constants_js_1 = require("./constants.js");
const sidecar_emitter_js_1 = require("./sidecar-emitter.js");
const payload_schemas_js_1 = require("./payload-schemas.js");
const target_js_1 = require("../decorators/sidecar/target.js");
class SidecarBody extends sidecar_emitter_js_1.SidecarEmitter {
    constructor(options) {
        super();
        config_js_1.log.verbose('SidecarBody', 'constructor(%s)', options
            ? `"${JSON.stringify(options)}`
            : '');
        this.initAgentScript = options?.initAgentScript;
        this.sidecarTarget = (0, target_js_1.normalizeSidecarTarget)(options?.sidecarTarget);
    }
    async [constants_js_1.INIT_SYMBOL]() {
        config_js_1.log.verbose('SidecarBody', '[INIT_SYMBOL]()');
        const Klass = this.constructor;
        const metadata = (0, metadata_sidecar_js_1.getMetadataSidecar)(Klass);
        if (!metadata) {
            throw new Error([
                'Sidecar:',
                'SidcarBody[INIT_SYMBOL]() getMetadataSidecar return undefined',
            ].join('\n'));
        }
        /**
         * 1. initAgentScript
         */
        if (this.initAgentScript) {
            config_js_1.log.silly('SidecarBody', '[INIT_SYMBOL]() initAgentScript has been specified from constructor args');
        }
        else {
            config_js_1.log.silly('SidecarBody', '[INIT_SYMBOL]() load initAgentScript from metadata');
            this.initAgentScript = metadata.initAgentScript || '';
        }
        /**
         * 2. sidecarTarget
         */
        if (this.sidecarTarget) {
            config_js_1.log.silly('SidecarBody', '[INIT_SYMBOL]() sidecarTarget has been specified from constructor args');
        }
        else {
            if (!metadata.sidecarTarget) {
                throw new Error([
                    'Sidecar must specify the "sidecarTarget"',
                    'either by the "@Sidecar" decorator,',
                    'or in the "constructor()" parameters.',
                ].join('\n'));
            }
            config_js_1.log.silly('SidecarBody', '[INIT_SYMBOL]() load sidecarTarget from metadata');
            this.sidecarTarget = metadata.sidecarTarget;
        }
        /**
         * 3. agentSource
         */
        this.agentSource = await (0, build_agent_source_js_1.buildAgentSource)({
            ...metadata,
            initAgentScript: this.initAgentScript || metadata.initAgentScript,
        });
        this.emit(constants_js_1.INIT_SYMBOL);
    }
    async [constants_js_1.ATTACH_SYMBOL]() {
        config_js_1.log.verbose('SidecarBody', '[ATTACH_SYMBOL]()');
        if (typeof this.agentSource === 'undefined') {
            await this[constants_js_1.INIT_SYMBOL]();
        }
        if (!(this.agentSource && this.sidecarTarget)) {
            throw new Error([
                'Sidecar:',
                'agentSource or sidecarTarget not found.',
            ].join('\n'));
        }
        const resumeCallbackList = [];
        let pid;
        let session;
        if ((0, target_js_1.isSidecarTargetProcess)(this.sidecarTarget)) {
            const targetProcess = this.sidecarTarget.target;
            try {
                session = await frida.attach(targetProcess);
                config_js_1.log.silly('SidecarBody', '[ATTACH_SYMBOL]() frida.attach(%s) succeed: pid = %s', this.sidecarTarget.target, session.pid);
            }
            catch (e) {
                config_js_1.log.silly('SidecarBody', '[ATTACH_SYMBOL]() attach(%s) failed: %s', targetProcess, e && e.message);
                this.emit('error', e);
                return;
            }
        }
        else if ((0, target_js_1.isSidecarTargetSpawn)(this.sidecarTarget)) {
            const [command] = this.sidecarTarget.target;
            let [, args] = this.sidecarTarget.target;
            args ?? (args = []);
            try {
                pid = await frida.spawn([command, ...args]);
                /**
                 * Huan(202107): Only save spawnPid
                 *  when we need to `frida.kill()` it within `detatch()`
                 */
                this.spawnPid = pid;
                session = await frida.attach(pid);
                resumeCallbackList.push(() => frida.resume(pid));
                config_js_1.log.silly('SidecarBody', '[ATTACH_SYMBOL]() friday.spawn(%s, [%s]) succeed: pid = %s', command, args.join(','), pid);
            }
            catch (e) {
                config_js_1.log.silly('SidecarBody', '[ATTACH_SYMBOL]() frida.attach(%s, [%s]) failed: %s', command, args.join(','), e && e.message);
                this.emit('error', e);
                return;
            }
        }
        else {
            throw new Error('SidecarBody: unknown sidecar target obj payload: ' + JSON.stringify(this.sidecarTarget));
        }
        const script = await session.createScript(this.agentSource);
        script.message.connect(this[constants_js_1.SCRIPT_MESSAGRE_HANDLER_SYMBOL].bind(this));
        script.destroyed.connect(this[constants_js_1.SCRIPT_DESTROYED_HANDLER_SYMBOL].bind(this));
        await script.load();
        if (script.exports && script.exports['init']) {
            // Huan(202106)
            // FIXME: do we need to call init() here?
            // It seems that frida will call init() automatically in CLI
            await script.exports['init']();
        }
        else {
            config_js_1.log.warn('SidecarBody', '[ATTACH_SYMBOL]() "init" not found in "script.exports"');
        }
        this.session = session;
        this.script = script;
        this.emit(constants_js_1.ATTACH_SYMBOL);
        /**
         * Delay resume after `emit`
         */
        while (true) {
            const fn = resumeCallbackList.pop();
            if (fn) {
                await fn();
            }
            else {
                break;
            }
        }
    }
    async [constants_js_1.DETACH_SYMBOL]() {
        config_js_1.log.verbose('SidecarBody', '[DETACH_SYMBOL]()');
        const script = this.script;
        const session = this.session;
        const spawnPid = this.spawnPid;
        this.script = undefined;
        this.session = undefined;
        this.spawnPid = undefined;
        if (!script || script.isDestroyed) {
            /**
             * Clean the system sliencely when the script has already been cleaned
             */
            try {
                await script?.unload();
            }
            catch (e) {
                config_js_1.log.silly('SidecarBody', '[DETACH_SYMBOL]() this.script.unload() rejection: %s', e && e.message);
            }
            try {
                await session?.detach();
            }
            catch (e) {
                config_js_1.log.silly('SidecarBody', '[DETACH_SYMBOL]() this.session.detach() rejection: %s', e && e.message);
            }
            try {
                if (spawnPid) {
                    await frida.kill(spawnPid);
                }
            }
            catch (e) {
                config_js_1.log.silly('SidecarBody', '[DETACH_SYMBOL]() frida.kill(%s) rejection: %s', spawnPid, e && e.message);
            }
            return;
        }
        if (script) {
            /**
             * Only call `unload()` if script is not destroyed
             */
            try {
                await script.unload();
            }
            catch (e) {
                config_js_1.log.error('SidecarBody', '[DETACH_SYMBOL]() script.unload() rejection: %s\n%s', e && e.message, e && e.stack);
                this.emit('error', e);
            }
        }
        if (session) {
            try {
                await session.detach();
            }
            catch (e) {
                config_js_1.log.error('SidecarBody', '[DETACH_SYMBOL]() session.detach() rejection: %s\n%s', e && e.message, e && e.stack);
                this.emit('error', e);
            }
        }
        else {
            config_js_1.log.silly('SidecarBody', '[DETACH_SYMBOL]() this.session is undefined');
        }
        if (spawnPid) {
            try {
                await frida.kill(spawnPid);
            }
            catch (e) {
                this.emit('error', e);
            }
        }
        this.emit(constants_js_1.DETACH_SYMBOL);
    }
    /**
     * ScriptDestroyedHandler
     */
    async [constants_js_1.SCRIPT_DESTROYED_HANDLER_SYMBOL]() {
        config_js_1.log.verbose('SidecarBody', '[SCRIPT_DESTROYED_HANDLER_SYMBOL]()');
        /**
         * Huan(202106): this function will be called
         *  when we call `script.unload()` from `[DETATCH_SYMBOL]()`
         *
         *  If that, the `this.script` should has already be set to undefined
         *  and we need not to call [DETATCH_SYMBOL]() again.
         */
        if (!this.script) {
            config_js_1.log.silly('SidecarBody', '[SCRIPT_DESTROYED_HANDLER_SYMBOL]() this.script is undefined. skipped');
            return;
        }
        try {
            await this[constants_js_1.DETACH_SYMBOL]();
        }
        catch (e) {
            this.emit('error', e);
        }
    }
    /**
     * ScriptMessageHandler
     */
    [constants_js_1.SCRIPT_MESSAGRE_HANDLER_SYMBOL](message, data) {
        config_js_1.log.silly('SidecarBody', '[SCRIPT_MESSAGRE_HANDLER_SYMBOL](%s, %s)', JSON.stringify(message), data);
        switch (message.type) {
            case frida.MessageType.Send:
                config_js_1.log.silly('SidecarBody', '[SCRIPT_MESSAGRE_HANDLER_SYMBOL]() MessageType.Send: %s', JSON.stringify(message.payload));
                if ((0, payload_schemas_js_1.isSidecarPayloadLog)(message.payload)) {
                    this[constants_js_1.LOG_EVENT_HANDLER](message.payload.payload);
                }
                else if ((0, payload_schemas_js_1.isSidecarPayloadHook)(message.payload)) {
                    this[constants_js_1.HOOK_EVENT_HANDLER](message.payload.payload);
                }
                else {
                    /**
                     * Unknown payload type
                     */
                    config_js_1.log.warn('SidecarBody', '[SCRIPT_MESSAGRE_HANDLER_SYMBOL](): unknown payload type %s: %s', message.payload.type, JSON.stringify(message.payload));
                    this.emit('error', new Error([
                        'SidecarBody got unknown message from Frida Agent:',
                        'Payload:',
                        JSON.stringify(message.payload, null, 2),
                    ].join('\n')));
                }
                break;
            case frida.MessageType.Error:
                config_js_1.log.error('SidecarBody', '[SCRIPT_MESSAGRE_HANDLER_SYMBOL]() MessageType.Error: %s', message.stack);
                {
                    const e = new Error(message.description);
                    e.stack = [
                        e.stack,
                        '----- Agent Script Internal -----',
                        message.stack,
                    ].join('\n');
                    this.emit('error', e);
                }
                break;
            default:
                this.emit('error', new Error([
                    'MessagingSidecar: [SCRIPT_MESSAGRE_HANDLER_SYMBOL]() Error: unknown message type:',
                    message?.type,
                    'message:',
                    message,
                ].join(' ')));
        }
        if (data) {
            config_js_1.log.silly('SidecarBody', '[SCRIPT_MESSAGRE_HANDLER_SYMBOL]() data:', data);
        }
    }
    [constants_js_1.LOG_EVENT_HANDLER](payload) {
        const prefix = `SidecarBody<${payload.prefix}>`;
        switch (payload.level) {
            case 'verbose':
                config_js_1.log.verbose(prefix, payload.message);
                break;
            case 'silly':
                config_js_1.log.silly(prefix, payload.message);
                break;
            default:
                throw new Error('unknown log payload: ' + JSON.stringify(payload));
        }
    }
    [constants_js_1.HOOK_EVENT_HANDLER](payload) {
        config_js_1.log.verbose('SidecarBody', '[HOOK_EVENT_HANDLER]("%s")', JSON.stringify(payload));
        this.emit('hook', payload);
    }
}
exports.SidecarBody = SidecarBody;
//# sourceMappingURL=sidecar-body.js.map