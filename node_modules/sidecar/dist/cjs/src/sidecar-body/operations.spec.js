#!/usr/bin/env -S node --no-warnings --loader ts-node/esm
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const tstest_1 = require("tstest");
const sidecar_body_js_1 = require("./sidecar-body.js");
const operations_js_1 = require("./operations.js");
const mod_js_1 = require("../decorators/mod.js");
const constants_js_1 = require("./constants.js");
const targetProgram = () => process.platform === 'linux' ? '/bin/ls'
    : process.platform === 'darwin' ? '/bin/ls'
        : process.platform === 'win32' ? 'c:\\Windows\\notepad.exe'
            : 'targteProgram(): Unknown process.platform:' + process.platform;
(0, tstest_1.test)('init()', async (t) => {
    let SidecarTest = class SidecarTest extends sidecar_body_js_1.SidecarBody {
    };
    SidecarTest = __decorate([
        (0, mod_js_1.Sidecar)([targetProgram()])
    ], SidecarTest);
    const s = new SidecarTest();
    const future = new Promise(resolve => s.on(constants_js_1.INIT_SYMBOL, resolve));
    try {
        await (0, operations_js_1.init)(s);
        await Promise.race([
            future,
            new Promise((resolve, reject) => {
                void resolve;
                setTimeout(reject, 100);
            }),
        ]);
        t.pass('init() successfully');
    }
    catch (e) {
        t.fail('Rejection:' + e && e.message);
        console.error(e);
    }
});
(0, tstest_1.test)('attach()', async (t) => {
    let SidecarTest = class SidecarTest extends sidecar_body_js_1.SidecarBody {
    };
    SidecarTest = __decorate([
        (0, mod_js_1.Sidecar)([targetProgram()])
    ], SidecarTest);
    const sidecar = new SidecarTest();
    sidecar.script = {
        unload: (..._) => { return {}; },
    };
    sidecar.session = {
        detach: (..._) => { return {}; },
    };
    const future = new Promise(resolve => sidecar.on(constants_js_1.ATTACH_SYMBOL, resolve));
    try {
        await (0, operations_js_1.attach)(sidecar);
        await Promise.race([
            future,
            new Promise((resolve, reject) => {
                void resolve;
                setTimeout(reject, 100);
            }),
        ]);
        t.pass('attach() successfully');
    }
    catch (e) {
        t.fail('Rejection:' + e && e.message);
    }
    finally {
        try {
            await (0, operations_js_1.detach)(sidecar);
        }
        catch (e) { }
    }
});
(0, tstest_1.test)('detach()', async (t) => {
    let SidecarTest = class SidecarTest extends sidecar_body_js_1.SidecarBody {
    };
    SidecarTest = __decorate([
        (0, mod_js_1.Sidecar)([targetProgram()])
    ], SidecarTest);
    const sidecar = new SidecarTest();
    sidecar.on('error', () => { });
    const future = new Promise(resolve => sidecar.on(constants_js_1.DETACH_SYMBOL, resolve));
    try {
        await (0, operations_js_1.init)(sidecar);
        await (0, operations_js_1.attach)(sidecar);
        await (0, operations_js_1.detach)(sidecar);
        await Promise.race([
            future,
            new Promise((resolve, reject) => {
                void resolve;
                setTimeout(reject, 100);
            }),
        ]);
        t.pass('detach() successfully');
    }
    catch (e) {
        t.fail('Rejection:' + e && e.message);
    }
});
//# sourceMappingURL=operations.spec.js.map