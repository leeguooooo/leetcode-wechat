"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.guardPointerType = exports.guardNativeType = void 0;
const undefinedNativeTypes = [
    'pointer',
    'void',
];
const undefinedPointerTypes = [];
const bufferNativeTypes = ['pointer'];
const bufferPointerTypes = ['ByteArray'];
const stringNativeTypes = ['pointer'];
const stringPointerTypes = [
    'AnsiString',
    'CString',
    'Utf16String',
    'Utf8String',
];
const numberNativeTypes = [
    'pointer',
    'int',
    'uint',
    'long',
    'ulong',
    'char',
    'uchar',
    'size_t',
    'ssize_t',
    'float',
    'double',
    'int8',
    'uint8',
    'int16',
    'uint16',
    'int32',
    'uint32',
    'int64',
    'uint64',
];
const numberPointerTypes = [
    'S8',
    'U8',
    'S16',
    'U16',
    'S32',
    'U32',
    'Short',
    'UShort',
    'Int',
    'UInt',
    'Float',
    'Double',
    'S64',
    'U64',
    'Long',
    'ULong',
];
const booleanNativeTypes = [
    'pointer',
    'bool',
];
const booleanPointerTypes = [];
/**
 * The main table for storing compatible native & pointer types for design types.
 */
const designTypesCompatibleTable = new Map()
    /**
     * Huan(202107): TypeScript can not get the ReturnType<Promise<???>> today (v4.4)
     */
    .set(Promise, [
    [],
    [],
])
    .set(undefined, [
    undefinedNativeTypes,
    undefinedPointerTypes,
])
    .set(Buffer, [
    bufferNativeTypes,
    bufferPointerTypes,
])
    .set(String, [
    stringNativeTypes,
    stringPointerTypes,
])
    .set(Number, [
    numberNativeTypes,
    numberPointerTypes,
])
    .set(Boolean, [
    booleanNativeTypes,
    booleanPointerTypes,
]);
const guardNativeType = (nativeType) => (designType) => {
    if (!designTypesCompatibleTable.has(designType)) {
        throw new Error(`Unsupported designType: ${(typeof designType)} ${(designType && designType.name)} ${designType}`);
    }
    const typeList = designTypesCompatibleTable.get(designType);
    if (!typeList) {
        throw new Error('nativeType can not found from designToNativeTypeTable[' + designType + ']');
    }
    const [nativeTypeList, _] = typeList;
    // [] means allow all
    if (nativeTypeList.length > 0 && !nativeTypeList.includes(nativeType)) {
        throw new Error(`NativeType(${nativeType}) does match the design type "${designType?.name}"`);
    }
};
exports.guardNativeType = guardNativeType;
const guardPointerType = (pointerTypeList) => (designType) => {
    let pointerType;
    if (pointerTypeList.length > 0) {
        pointerType = pointerTypeList[pointerTypeList.length - 1];
    }
    else {
        /**
         * Huan(202107): NativePointer allow raw pointer (`null` as well)
         */
        pointerType = 'Pointer';
    }
    if (!designTypesCompatibleTable.has(designType)) {
        throw new Error(`Unsupported designType: ${(typeof designType)} ${(designType && designType.name)} ${designType}`);
    }
    const typeList = designTypesCompatibleTable.get(designType);
    if (!typeList) {
        throw new Error('pointerType can not found from designToPointerTypeTable[' + designType + ']');
    }
    // console.log(typeList)
    const [_, compatiblePointerTypeList] = typeList;
    /**
     * Huan(202106): why `typeList.length > 0`?
     *  nativeTypeList will be empty for the designType `Promise`
     *  because the TypeScript metadata do not support to get the value inside the `Promise<value>`
     *  so we will not be able to check them.
     */
    // [] means allow all
    if (compatiblePointerTypeList.length > 0 && !compatiblePointerTypeList.includes(pointerType)) {
        throw new Error(`PointerType(${pointerType}) does match the design type "${designType?.name}"`);
    }
};
exports.guardPointerType = guardPointerType;
//# sourceMappingURL=type-guard.js.map